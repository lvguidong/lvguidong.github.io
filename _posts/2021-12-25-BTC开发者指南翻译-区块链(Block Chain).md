---
layout: post
title: BTC开发者指南翻译-区块链(Block Chain)
tags: 
- 区块链
- BlockChain
- BTC
date: 2021-12-25 16:00 +0800
---
翻译原文在 [**这里**](https://developer.bitcoin.org/devguide/block_chain.html)

# 区块链(Block Chain)
区块链提供了比特币的公共账本(ledger)，一个有序的(ordered)、带有时间戳的(timestamped)交易记录。该系统用于防止双重支付(double spending)和修改以前的交易记录

# 介绍(Introdution)
比特币网络中的每个完整节点独立存储一个区块链，其中仅包含由该节点验证的区块。当多个节点在其区块链中都拥有相同的区块时，则认为它们已达成共识(consensus)。这些节点为维持共识而遵循的验证规则称为共识规则(consensus rules)。本节描述了 Bitcoin Core 使用的许多共识规则。
<img src="https://github.com/lvguidong/lvguidong.github.io/blob/main/_posts/images/btc_tr_blockchain1.svg?raw=true?raw=true" alt="block-min" />

上图显示了区块链的简化版本。一个或多个新交易的区块被收集到区块的交易数据部分。每笔交易的副本都会被哈希(hashed)，然后将哈希配对、哈希、再次配对、再哈希，直到剩下一个哈希，即默克尔树(merkle tree)的默克尔根(merkle root)。

默克尔根存储在区块头(block header)中。每个区块还存储前一个区块头的哈希值，将这些区块链接在一起。这确保在不修改记录它的块和所有后续块的情况下无法修改。

交易也被链接(chained)在一起。比特币钱包软件给人的印象是聪(satoshis)是从钱包发送到钱包，但比特币确实在交易之间移动。每笔交易都会花费先前在一个或多个早期交易中收到的聪，因此一笔交易的输入是前一笔交易的输出。
<img src="https://developer.bitcoin.org/_images/en-transaction-propagation.svg" alt="block-min" />

单个交易可以创建多个输出(multiple outputs)，就像发送到多个地址时的情况一样，但特定交易的每个输出在区块链中只能用作输入一次(once)。任何后续引用都是被禁止的双花(double spend)——试图两次花费相同的聪。

输出与交易标识符 (TXID) 相关联，交易标识符是已签名交易的哈希值。

由于特定交易的每个输出只能花费一次(spent once)，因此区块链中包含的所有交易的输出可以归类为未花费的交易输出（UTXO）或已花费的交易输出。要使付款有效(valid)，它必须仅使用 UTXO 作为输入。

忽略 coinbase 交易（稍后描述），如果交易的输出值超过其输入值，则该交易将被拒绝(rejected)——但如果输入值超过输出值，则任何价值差异都可能被比特币认作交易费创建包含该交易的区块的矿工。例如，在上图中，每笔交易的花费比从其组合输入中收到的少 10,000 satoshis，实际上支付了 10,000 satoshi 交易费。

# 工作量证明(Proof of Work)
区块链是由网络上的匿名节点(anonymous peers)协作维护的，因此比特币要求每个区块都证明在其创建上投入了大量工作(invested in its creation)，以确保想要修改过去区块的不可信节点必须比只修改过去区块的诚实节点更努力地工作想要向区块链添加新区块。

将区块链接在一起(Chaining blocks together)使得在不修改所有后续区块的情况下修改任何区块中包含的交易是不可能的。因此，随着区块链中每增加一个新区块，修改特定区块的成本就会增加(increases)，从而放大了工作量证明的效果。

比特币中使用的工作量证明(pow)利用了加密哈希(cryptographic hashes)的明显随机性。一个好的加密散列算法将任意数据转换为看似随机的数字。如果以任何方式修改数据并重新运行散列，则会产生一个新的看似随机的数字，因此无法修改数据以使哈希可预测(predictable)。

为了证明你做了一些额外的工作来创建一个块，你必须创建一个不超过某个值的块头的哈希值。例如，如果最大可能的哈希值为 2^256 − 1，您可以通过生成小于 2^255 的哈希值来证明您尝试了多达两种组合。

在上面给出的示例中，您将平均每隔一次尝试就产生一个成功的散列。您甚至可以估计给定哈希尝试生成低于目标阈值的数字的概率。比特币假设一个线性概率，它使目标阈值越低，需要尝试的哈希尝试（平均）越多。

只有当新区块的哈希值至少与共识协议预期的难度值(difficulty value)一样具有挑战性时，才会将新区块添加到区块链中。每 `2,016` 个区块，网络使用存储在每个区块头中的时间戳来计算最后 2,016 个区块的第一个和最后一个生成之间经过的秒数。理想值是 `1,209,600` 秒（两周）。

- 如果生成 2,016 个区块的时间少于两周，则预期难度值会按比例增加(increased)（最多增加 `300%`），因此，如果以相同的速度检查哈希值，接下来的 2,016 个区块应该正好需要两周的时间来生成。
- 如果生成区块的时间超过两周，出于同样的原因，预期难度值会按比例降低（最多 `75%`）。

>（注意：比特币核心实现中的一个逐一错误(an off-by-one error)导致使用仅 2,015 个块的时间戳每 2,016 个块更新一次难度，造成轻微的偏差。）

因为每个区块头必须散列到低于目标阈值(target threshold)的值，并且因为每个区块都链接到它之前的区块，所以传播修改后的区块需要（平均）与整个比特币网络在两个区块之间消耗的哈希算力(hashing power)一样多。创建原始块的时间和当前时间。只有当你获得了网络的大部分哈希算力时，你才能可靠地对交易历史执行 51% 的攻击（尽管应该注意，即使不到 50% 的哈希算力仍然有很好的机会执行此类攻击）。

区块头(block header)提供了几个易于修改的字段，例如专用的 `nonce` 字段，因此获取新的哈希不需要等待新的交易。此外，只有 `80` 字节的区块头被哈希用于工作量证明，因此在一个区块中包含大量交易数据不会因额外的 I/O 而减慢哈希(slow down hashing)，而添加额外的交易数据只需要重新计算祖先在默克尔树中哈希。

# 区块高度和分叉(Block Height And Forking)
任何成功将区块头哈希到低于目标阈值的值的比特币矿工(miner)都可以将整个区块添加到区块链中（假设该区块是有效的）。这些块通常通过它们的块高度来寻址(addressed by their block height)——它们与第一个比特币块（块 0，最常称为创世块(genesis block)）之间的块数。例如，块 2016 是首先调整难度的地方。
<img src="https://developer.bitcoin.org/_images/en-blockchain-fork.svg" alt="btc fork" />
常见和不常见的区块链分叉

多个区块都可以具有相同的区块高度(same block height)，这在两个或多个矿工大致同时生产一个区块时很常见。这会在区块链中创建一个明显的分叉，如上图所示。

当矿工在区块链末端同时(simultaneous)产生区块时，每个节点单独选择接受哪个区块。在没有其他考虑的情况下，如下所述，节点通常使用它们看到的第一个块。

最终，矿工产生另一个块，该块仅附加到一个同时开采的竞争块(the competing simultaneously-mined blocks)上。这使得前叉的那一侧比另一侧更坚固。假设一个分叉只包含有效块，普通节点总是遵循最困难的链来重新创建并丢弃属于较短分叉的陈旧块(stale blocks)。 （陈旧块有时也称为孤块(orphan blocks))，但这些术语也用于没有已知父块的真正孤块。）

如果不同的矿工出于不同目的而工作，那么长期分叉是可能的，例如一些矿工在努力扩展区块链的同时，其他矿工正在尝试进行 `51%` 攻击以修改交易历史记录。

由于在区块链分叉过程中多个区块可以具有相同的高度(same height)，因此不应将区块高度用作全局唯一标识符。相反，块通常由其标头的哈希值引用（通常字节倒序，并以十六进制表示）

# 交易数据(Transaction Data)




